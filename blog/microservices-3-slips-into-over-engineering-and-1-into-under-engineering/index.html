<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Deliver fast by studying how you can keep things simple when dealing with microservice architectures."><meta property="og:type" content="article"><meta property="og:title" content="Microservices: 3 slips into over-engineering and 1 into under-engineering"><meta property="og:url" content="https://www.codelime.blog/microservices-3-slips-into-over-engineering-and-1-into-under-engineering/index.html"><meta property="og:site_name" content="Code Lime"><meta property="og:description" content="Deliver fast by studying how you can keep things simple when dealing with microservice architectures."><meta property="og:locale" content="en"><meta property="og:image" content="https://www.codelime.blog/images/logo.png"><meta property="og:updated_time" content="2019-08-25T09:43:43.927Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Microservices: 3 slips into over-engineering and 1 into under-engineering"><meta name="twitter:description" content="Deliver fast by studying how you can keep things simple when dealing with microservice architectures."><meta name="twitter:image" content="https://www.codelime.blog/images/logo.png"><link rel="shortcut icon" href="../images/favicon.ico"><link rel="icon" type="image/png" href="../images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"><title>Microservices: 3 slips into over-engineering and 1 into under-engineering</title><link rel="stylesheet" href="../css/style.css"><link rel="stylesheet" href="../css/rtl.css"></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><header id="header"><a href="../index.html"><div id="logo" style="background-image:url(../images/logo.png)"></div><div id="title"><h1>Code Lime</h1></div></a><div id="nav"><ul><li class="icon"><a href="index.html#"><i class="fas fa-bars fa-2x"></i></a></li><li><a href="../index.html">Home</a></li><li><a href="../about/index.html">About</a></li><li><a href="../posts.html">Writing</a></li><li class="icon"></li> </ul></div></header><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Microservices: 3 slips into over-engineering and 1 into under-engineering</h1><div class="meta"><span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Code Lime</span></span><div class="postdate"><time datetime="2019-08-25T09:41:18.000Z" itemprop="datePublished">2019-08-25</time></div></div></header><div class="content" itemprop="articleBody"><p>In this article I make a case for simplicity when designing a microservice based architecture. When done right they yield valuable advantages<br>such as autonomy and flexibility, but are paired with over-the-wire latency and deployment/hosting costs. This is not an advanced guided, but rather I want to help you question if you really need X approach, does it make to have a new process spin for it, can you have a glimpse of the hidden costs.</p><p>The links towards different technologies are not part of any sponsorship deal.</p><h2 id="Mapper-services"><a href="index.html#Mapper-services" class="headerlink" title="Mapper services"></a>Mapper services</h2><p>Personally, I find this case awkward.</p><p>You might come to this decision when service A needs to call service B. But of course, you need to map the DTO from domain A to what input B expects. In an overzealous love for microservice and attempt of decoupling the two, you create service C. It receives some data as JSON and returns a slightly rearrangement of it. No more information.</p><p>But by this logic, now you could consider to have 3 systems coupled. The case described is actually a DTO to DTO mapping, which belongs inside a process. Else, one could make the absurd case of needing to implement a mapper from A to C. Unless C doesn’t add data on the entity, (details, relation to other entities) C does not justify its existence. A service should return data it owns.</p><p>In the same manner, would you make a service to sort you an array of numbers it gets as input?</p><h2 id="Wrapper-services-over-static-content"><a href="index.html#Wrapper-services-over-static-content" class="headerlink" title="Wrapper services over static content"></a>Wrapper services over static content</h2><p>Not everything needs building a microservice for. When you have website resources such as scripts, style sheets, or images, one way is to serve them from the main server, and the other is from a <a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener">CDN</a>.</p><p>On the backend side, if you read some simple string values at initialization phase in a service, values that will change once every few month, even every few days, consider a cold storage and maybe <a href="https://en.wikipedia.org/wiki/Polling_(computer_science)" target="_blank" rel="noopener">polling</a>, see <a href="https://aws.amazon.com/s3/" target="_blank" rel="noopener">S3</a> or <a href="https://azure.microsoft.com/en-us/services/storage/blobs/" target="_blank" rel="noopener">BlobStorage</a>. Care about authorized access? Research how you could restrict access based on IP or domain.<br>Hence, think really hard if you need a microservice for such content, in which you would pour maintenance and hosting costs.</p><p><strong>Note</strong> The persistence store has to be distributed and scalable. The data needs to be at <code>key-value</code> pair level of simplicity from you applications point of view. Otherwise you end up in the “hitting same database” situation presented at the last point.</p><h2 id="App-specific-configuration-hosted-by-a-remote-service"><a href="index.html#App-specific-configuration-hosted-by-a-remote-service" class="headerlink" title="App specific configuration hosted by a remote service"></a>App specific configuration hosted by a remote service</h2><p>Number of threads in some pool? Retry policies? Local in-memory cache durations? Does it make sense to have it in a far away service? There are chances that some values can reside pretty well in a settings file or as environment variables, so try this first. When proven otherwise, explore some already existing tools for configuration such as <a href="https://learn.hashicorp.com/consul" target="_blank" rel="noopener">Consul</a>, and save on that expensive development costs.</p><h2 id="Hitting-the-same-database-from-several-microservices"><a href="index.html#Hitting-the-same-database-from-several-microservices" class="headerlink" title="Hitting the same database from several microservices"></a>Hitting the same database from several microservices</h2><p>Now this is the case when you had kept things too simple. It won’t take long until the database server will run out of connections, space, or computing power. Depending on the permissions each microservice has, an ugly scenario would be that it deletes objects such as tables that are used by another process. Also consider that if two such clients happen to read from the same table, and the schema has to change for one of them then you have to modify or at least adapt the second client for it to continue working. Sounds like a distributed monolith to me.</p><p>Doing so almost refutes the whole philosophy of microservice architecture. They should be independent and self-contained. They should own their data and have complete freedom on <em>how</em> it is persisted. They are abstractions that help de-couple processes. Obviously, they come with a fair amount of overhead for this flexibility. Yet, <em>flexibility</em> is what you should aim for.</p><p>Microservices should communicate via their explicitly exposed APIs. Over <code>HTTP</code> you can choose from <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">ReST</a>, <a href="https://graphql.org/" target="_blank" rel="noopener">GraphQL</a>, <a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a> or you may pick from the message queue implementations such as <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a>, <a href="https://kafka.apache.org/" target="_blank" rel="noopener">ApacheKafka</a>.</p><h2 id="Conclusion"><a href="index.html#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Whilst, hopefully, most of you are well aware of the points above, others might be guilty of those slips. Maybe some would have been if not for this post. In any case, making mistakes especially in the somewhat novel and shape-shifting world of microservice is something we should expect and learn from. Hey, it could be me that’s still not getting it. Thanks for reading!</p><div class="pagination"><a class="pag-anchor" href="../constructive-thoughts-after-a-failure/index.html"><i class="fas fa-angle-left pag-anchor">&lt older</i></a> <a class="pag-anchor" href="../save-money-by-caching-paid-apis-with-cloudfront/index.html"><i class="fas fa-angle-right pag-anchor">newer &gt</i></a></div></div></article><footer id="footer"><div class="footer-left">Copyright &copy; 2022 Randy Miller</div><div class="footer-right"><nav><ul><li><a href="../index.html">Home</a></li><li><a href="../about/index.html">About</a></li><li><a href="../posts.html">Writing</a></li><li><a href="https://twitter.com/randy_mllr">Twitter</a></li></ul></nav></div></footer></div><script>!function(t,e,a,c,n,o){e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},n=t.createElement("script"),o=t.getElementsByTagName("script")[0],n.async=1,n.src="//cdn.usefathom.com/tracker.js",n.id="fathom-script",o.parentNode.insertBefore(n,o)}(document,window,0,"fathom"),fathom("set","siteId","YFKINOVA"),fathom("trackPageview")</script></body></html>