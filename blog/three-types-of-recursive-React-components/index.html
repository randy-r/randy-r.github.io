<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Recursion is one of the most elegant techniques in mathematics and computer science - see how you can can apply it to UI elements."><meta property="og:type" content="article"><meta property="og:title" content="Three types of recursive React components"><meta property="og:url" content="https://www.codelime.blog/three-types-of-recursive-React-components/index.html"><meta property="og:site_name" content="Code Lime"><meta property="og:description" content="Recursion is one of the most elegant techniques in mathematics and computer science - see how you can can apply it to UI elements."><meta property="og:locale" content="en"><meta property="og:image" content="https://www.codelime.blog/images/thumbnails/three-types-of-recursive-React-components.jpg"><meta property="og:updated_time" content="2020-06-13T09:30:06.149Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Three types of recursive React components"><meta name="twitter:description" content="Recursion is one of the most elegant techniques in mathematics and computer science - see how you can can apply it to UI elements."><meta name="twitter:image" content="https://www.codelime.blog/images/thumbnails/three-types-of-recursive-React-components.jpg"><link rel="shortcut icon" href="../images/favicon.ico"><link rel="icon" type="image/png" href="../images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="../images/apple-touch-icon.png"><title>Three types of recursive React components</title><link rel="stylesheet" href="../css/style.css"><link rel="stylesheet" href="../css/rtl.css"></head><body class="max-width mx-auto px3 ltr"><div class="content index py4"><header id="header"><a href="../index.html"><div id="logo" style="background-image:url(../images/logo.png)"></div><div id="title"><h1>Code Lime</h1></div></a><div id="nav"><ul><li class="icon"><a href="index.html#"><i class="fas fa-bars fa-2x"></i></a></li><li><a href="../index.html">Home</a></li><li><a href="../about/index.html">About</a></li><li><a href="../posts.html">Writing</a></li><li class="icon"></li> </ul></div></header><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Three types of recursive React components</h1><div class="meta"><span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Code Lime</span></span><div class="postdate"><time datetime="2020-06-05T12:50:00.000Z" itemprop="datePublished">2020-06-05</time></div></div></header><div class="content" itemprop="articleBody"><p>You have probably used <a href="https://en.wikipedia.org/wiki/Recursion#In_computer_science" target="_blank" rel="noopener">recursion</a> by now on other, more data centring, problems, but it can be a valid approach when coding UI components. Here’s a simple take on the topic, using <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>.</p><p>When I think of recursive components three main cases that are worth talking about come to mind.</p><h1 id="Purely-visual"><a href="index.html#Purely-visual" class="headerlink" title="Purely visual"></a>Purely visual</h1><p>These components are mainly for flashy display. Some of them can have the self-similarity quality of geometrical <a href="https://en.wikipedia.org/wiki/Fractal" target="_blank" rel="noopener">fractals</a> but in day to day web development they are required to be less visually complex than a fractal. One would consider this method when creating unique icons or backgrounds, or even wacky plots.</p><p>Taking the common element, the <code>div</code>, a minimal code example for this case would look like:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computeColor = <span class="function">(<span class="params">currentDept, maxDepth</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> green = <span class="number">255</span> * currentDept / maxDepth;</span><br><span class="line">    <span class="keyword">const</span> opacity = <span class="number">0.1</span> + currentDept / maxDepth * <span class="number">0.9</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`rgba(0, <span class="subst">$&#123;green&#125;</span>, 0, <span class="subst">$&#123;opacity&#125;</span>)`</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Squares = <span class="function">(<span class="params">&#123; currentDept = <span class="number">0</span>, maxDepth = <span class="number">10</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// stop condition</span></span><br><span class="line">    <span class="keyword">if</span> (currentDept &gt;= maxDepth) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="xml">        backgroundColor: computeColor(currentDept, maxDepth),</span></span><br><span class="line"><span class="xml">        width: 100, height: 100, left: 30,</span></span><br><span class="line"><span class="xml">        transform: `rotate($&#123;currentDept / maxDepth * 45&#125;deg)`,</span></span><br><span class="line"><span class="xml">        transformOrigin: '0% 100%',  </span></span><br><span class="line"><span class="xml">        position: 'relative',</span></span><br><span class="line"><span class="xml">    &#125;&#125;&gt;</span></span><br><span class="line">        &lt;Squares currentDept=&#123;currentDept + 1&#125; maxDepth=&#123;maxDepth&#125; /&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// and then call it where ever as</span></span><br><span class="line">&lt;Squares currentDept=&#123;0&#125; maxDepth=&#123;5&#125; /&gt;</span><br></pre></td></tr></table></figure><p>The component paints a div with dome specific styles dependent on the current depth and then calls itself with an incremented depth counter. As in the case of traversing a list or a tree, this can be done iteratively instead of recursively, for a small depth value performance is not an worthwhile issue and thus it becomes a matter of which approach is more concise in the developer’s eyes.</p><p>The visual output looks as follows:</p><div style="height:260px"><div style="background-color:rgba(0,0,0,.1);width:100px;height:100px;left:30px;transform:rotate(0);transform-origin:0 100% 0;position:relative"><div style="background-color:rgba(0,51,0,.28);width:100px;height:100px;left:30px;transform:rotate(9deg);transform-origin:0 100% 0;position:relative"><div style="background-color:rgba(0,102,0,.46);width:100px;height:100px;left:30px;transform:rotate(18deg);transform-origin:0 100% 0;position:relative"><div style="background-color:rgba(0,153,0,.64);width:100px;height:100px;left:30px;transform:rotate(27deg);transform-origin:0 100% 0;position:relative"><div style="background-color:rgba(0,204,0,.82);width:100px;height:100px;left:30px;transform:rotate(36deg);transform-origin:0 100% 0;position:relative"></div></div></div></div></div></div><br><br><br><br><br><br><h1 id="Graph-data-with-constant-display"><a href="index.html#Graph-data-with-constant-display" class="headerlink" title="Graph data with constant display"></a>Graph data with constant display</h1><p>This case has actual more real life use cases and it is the easiest case when it comes to recursive renderings. Consider having a tree or graph whose nodes represent, let’s say, the product categories in a shop and the end user would need to navigate between them. Any of these nodes can be rendered by the same panel, all being orchestrated by React’s state. I would say this is a good approach on mobile screens.</p><p>Notice that here you do <em>not</em> need to recursively call the component.</p><p>To enable back navigation we need a reference to each node’s parent. The approach I used is a prior parsing of data and attaching the parent to each object. For this to work, it’s important to use the same object references as this provides the freedoms to navigate the graph. I would advise to attach the parents somewhere out of the rendering flow, right after data fetching or in a <a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener"><code>useEffect</code> hook</a>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pure component that renders a given node</span></span><br><span class="line"><span class="keyword">const</span> GraphDisplay = <span class="function">(<span class="params">&#123; node, onNodeClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;node.children?.map(c =&gt;</span></span><br><span class="line">            &lt;button</span><br><span class="line">                key=&#123;c.text&#125;</span><br><span class="line">                onClick=&#123;() =&gt; onNodeClick(c)&#125;&gt;</span><br><span class="line">                &#123;c.text&#125;</span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        )&#125;</span></span><br><span class="line"><span class="xml">        &#123;node.parent ?</span></span><br><span class="line">            &lt;button</span><br><span class="line">                onClick=&#123;() =&gt; onNodeClick(node.parent)&#125;&gt;</span><br><span class="line">                Go back to &#123;node.parent.text&#125;</span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            : <span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stateful component that keeps track of the current node,</span></span><br><span class="line"><span class="comment">// with a minimal (and optional) display of it's data</span></span><br><span class="line"><span class="keyword">const</span> GraphContainer = <span class="function">(<span class="params">&#123; node: graphNode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [node, setNode] = useState(graphNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Viewing &#123;node.text&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">        &lt;GraphDisplay node=&#123;node&#125; onNodeClick=&#123;n =&gt; setNode(n)&#125; /&gt;</span><br><span class="line">    &lt;/&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// declaration of the helper function that will link nodes to their parents</span><br><span class="line">const attachParents = (node, parent) =&gt; &#123;</span><br><span class="line">    node.parent = parent;</span><br><span class="line">    if (!node.children)</span><br><span class="line">        return;</span><br><span class="line">    for (const c of node.children) &#123;</span><br><span class="line">        attachParents(c, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// ...</span><br><span class="line">// actual data </span><br><span class="line">const root = &#123;</span><br><span class="line">    text: 'Home', children: [&#123;</span><br><span class="line">        text: 'Shirts', children: [</span><br><span class="line">            &#123; text: 'T-Shirts' &#125;,</span><br><span class="line">            &#123; text: 'Dress Shirts' &#125;]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        text: 'Coats', children: [</span><br><span class="line">            &#123; text: 'Trench Coats' &#125;,</span><br><span class="line">            &#123; text: 'Rain Coats' &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">attachParents(root); // do this out of the rendering loop, preferably</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">// rendering of the main component with enhanced data</span><br><span class="line">&lt;GraphContainer node=&#123;root&#125; /&gt;</span><br></pre></td></tr></table></figure><p>The code will behave as (with some minimal styles):</p><figure><video controls autoplay allowfullscreen style="max-width:250px"><source src="../images/three-types-of-recursive-React-components-1.webm" type="video/webm"></video></figure><h1 id="Graph-data-with-unfolding-display"><a href="index.html#Graph-data-with-unfolding-display" class="headerlink" title="Graph data with unfolding display"></a>Graph data with unfolding display</h1><p>This case is similar with the above one, only that it keeps the whole hierarchy path on screen. Almost all desktop programs implement this in menu displays. The code will use the category data from the previous example, but with a T-Shirts being split into a couple more sections.</p><p>Some key points for this case would be that now the component does call itself because we need to have multiple such visual instances on the screen at the same time. State also holds the child for which to further expand its children, and not the current node, and we don’t need a parent attached to each node because there is we don’t deal with back pagination in this case. In short, you render the a child the same way you rendered the parent node.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pure component that renders a given node's children</span></span><br><span class="line"><span class="keyword">const</span> GraphMenuDisplay = <span class="function">(<span class="params">&#123; node, onNodeClick &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node.children || node.children?.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;node.children.map(c =&gt;</span></span><br><span class="line">            &lt;button</span><br><span class="line">                key=&#123;c.text&#125;</span><br><span class="line">                onClick=&#123;() =&gt; onNodeClick(c)&#125;&gt;</span><br><span class="line">                &#123;c.text&#125;</span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the stateful container that controls what child of the current node to expand</span></span><br><span class="line"><span class="keyword">const</span> GraphMenuContainer = <span class="function">(<span class="params">&#123; node: graphNode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [child, setChild] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleNodeClick = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> actualChild = graphNode?.children?.find(<span class="function"><span class="params">c</span> =&gt;</span> c === n);</span><br><span class="line">        <span class="keyword">if</span> (actualChild) &#123;</span><br><span class="line">            setChild(actualChild);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setChild(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// the component can remain mounted with a previous/stale state</span></span><br><span class="line">        <span class="comment">// therefore it needs to update if the child does not belong to the current node</span></span><br><span class="line">        <span class="keyword">if</span> (child === <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> actualChild = graphNode?.children?.find(<span class="function"><span class="params">c</span> =&gt;</span> c === child);</span><br><span class="line">        <span class="keyword">if</span> (!actualChild)</span><br><span class="line">            setChild(<span class="literal">null</span>);</span><br><span class="line">    &#125;, [child, graphNode]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">        &lt;GraphMenuDisplay node=&#123;graphNode&#125; onNodeClick=&#123;handleNodeClick&#125; /&gt;</span><br><span class="line">        &#123;child &amp;&amp; &lt;GraphMenuContainer node=&#123;child&#125; /&gt;&#125;</span><br><span class="line">    &lt;/&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">// ...</span><br><span class="line">// actual data shape</span><br><span class="line">const menuRoot = &#123;</span><br><span class="line">    text: 'Home', children: [&#123;</span><br><span class="line">        text: 'Shirts', children: [</span><br><span class="line">            &#123; text: 'T-Shirts', children: [</span><br><span class="line">                    &#123; text: 'Printed' &#125;,</span><br><span class="line">                    &#123; text: 'Plain' &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123; text: 'Dress Shirts' &#125;]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        text: 'Coats', children: [</span><br><span class="line">            &#123; text: 'Trench Coats' &#125;,</span><br><span class="line">            &#123; text: 'Rain Coats' &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line">//...</span><br><span class="line">// usage in app</span><br><span class="line">&lt;GraphMenuContainer node=&#123;menuRoot&#125; /&gt;</span><br></pre></td></tr></table></figure><p>Again, the a minimal styled display could look like this.</p><figure><video controls autoplay allowfullscreen><source src="../images/three-types-of-recursive-React-components-2.webm" type="video/webm"></video></figure><p>Of course, you are free to extend the handling of the item selection the way it fits your needs.</p><h1 id="Conclusion"><a href="index.html#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In a more general sense many of use have already build similar stuff, like breadcrumbs and filters that would show the same page layout but seeded by another set of items.</p><p>The mentioned cases can be extended and combined endlessly once you get the gist of it. Most likely, there is a fair amount of work to tailor for specific requirements and visual goals, but I hope this post will be a source of initial inspiration.</p><div style="height:20px;vertical-align:middle;line-height:20px;font-size:11px;color:#666;margin:6px 0 0 0">Thumbnail image copyright © Chris Foss.</div><div class="pagination"><a class="pag-anchor" href="../element-resize-dom-events-and-css-queries/index.html"><i class="fas fa-angle-left pag-anchor">&lt older</i></a> <a class="pag-anchor" href="../lists-are-your-friends/index.html"><i class="fas fa-angle-right pag-anchor">newer &gt</i></a></div></div></article><footer id="footer"><div class="footer-left">Copyright &copy; 2022 Randy Miller</div><div class="footer-right"><nav><ul><li><a href="../index.html">Home</a></li><li><a href="../about/index.html">About</a></li><li><a href="../posts.html">Writing</a></li><li><a href="https://twitter.com/randy_mllr">Twitter</a></li></ul></nav></div></footer></div><script>!function(t,e,a,c,n,o){e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},n=t.createElement("script"),o=t.getElementsByTagName("script")[0],n.async=1,n.src="//cdn.usefathom.com/tracker.js",n.id="fathom-script",o.parentNode.insertBefore(n,o)}(document,window,0,"fathom"),fathom("set","siteId","YFKINOVA"),fathom("trackPageview")</script></body></html>